### 线程池原理

通过c++11的新特性实现一个线程池，通过管理一个任务队列、线程队列，将主线程中用户提交任务到一任务队列中，空闲的线程将从任务队列中获取任务并执行，用户可以异步的获取提交任务的执行结果。
这里的任务调度执行策略为：任务队列无上限，同时执行任务的数量固定，有空闲线程时获取队列中的队头任务。
线程池的线程是复用的，线程池中的线程创建后不销毁，直到线程池关闭退出。每个线程创建后，循环执行从任务队列获取任务并执行。
线程池与任务队列之间需要匹配，是一个典型的消费者-生产者模型，需要解决资源访问冲突，并且保证任务为空时，线程应该等待（阻塞），即需要实现线程安全、有同步机制的任务队列。



### 用到多个c++11新特性：

#### 完美转发
std::bind中出现了一个std::forward()的特殊方法。std::forward()又被称作完美转发，简单来说，std::forward()将会完整保留参数的引用类型进行转发。
完美转发使用两步来完成任务：
1. 在模板中使用&&接收参数。
    F&& f和Args&&... args中的&&并非是右值引用意思，而是一种特殊现象，这个现象被称作万能引用（universal reference）。万能引用可以简单理解为，当T是模板参数时，T&&的作用主要是保持值类别进行转发。
2. 使用std::forward()转发给被调函数.
    std::forward会将输入的参数原封不动地传递到下一个函数中，这个“原封不动”指的是，如果输入的参数是左值，那么传递给下一个函数的参数的也是左值；如果输入的参数是右值，那么传递给下一个函数的参数的也是右值。



#### 可变模版参数

template<typename F, typename... Args>中的typename... Args是C++11引入的可变模版参数（variadic templates）
函数头部分auto submit(F &&f, Args &&...args) -> std::future<decltype(f(args...))>，这里函数类型的定义用到了叫做“尾返回类型推导”的技巧。在c++14前，关键字auto不能用于函数参数的类型推导，也不能推导函数的返回类型。



#### future异步获取

std::thread 是C++11中提供异步创建多线程的工具，只能是异步运行任务，却无法获取任务执行的结果，一般都是依靠全局对象，全局对象在多线程下是及其不安全的;
为此标准库提供了std::future类模板来关联线程运行的函数和函数的返回结果，这种获取结果的方式是异步的。
std::future 通常由某个 Provider 创建，你可以把 Provider 想象成一个异步任务的提供者，Provider 在某个线程中设置共享状态的值，与该共享状态相关联的 std::future 对象调用 get（通常在另外一个线程中）获取该值，如果共享状态的标志不为 ready，则调用 std::future::get 会阻塞当前的调用者，直到 Provider 设置了共享状态的值变为ready，std::future::get 返回异步任务的值或异常（如果发生了异常）。另外可以使用std::future的wait()方法来设置屏障，阻塞线程，实现线程同步。并最终使用std::future的get()方法来获得执行结果。



#### packeged_task包装

c++11中的std::packaged_task是个模板类。std::packaged_task包装任何可调用目标(函数、lambda表达式、bind表达式、函数对象)以便它可以被异步调用。它的返回值或抛出的异常被存储于能通过std::future对象访问的共享状态中。std::packaged_task不会自己启动，你必须调用它。
智能指针将更方便我们对该std::packaged_task对象进行管理， 并且所有权进行转移到线程池中，否则临时对象将在submit函数生命周期结束后销毁。



#### 仿函数

仿函数（functor）就是使用起来像函数一样的东西。如果对某个class或结构体进行()重载，它就是一个仿函数类。可以表现的像一个函数一样直接调用。



#### 条件变量

简要介绍条件变量std::condition_variable ，是为了解决死锁而生，当互斥操作不够用而引入的。比如，线程可能需要等待某个条件为真才能继续执行，而一个忙等待循环中可能会导致所有其他线程都无法进入临界区使得条件为真时，就会发生死锁。所以，condition_variable实例被创建出现主要就是用于唤醒等待线程从而避免死锁。std::condition_variable的notify_one()用于唤醒一个线程；notify_all()则是通知所有线程。